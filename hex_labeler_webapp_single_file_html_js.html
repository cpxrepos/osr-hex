<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hex Labeler</title>
  <style>
    :root { --panel-w: 340px; --accent: #222; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    body { display: grid; grid-template-columns: var(--panel-w) 1fr; gap: 0; }
    aside { padding: 14px 14px 18px; border-right: 1px solid #ddd; overflow:auto; }
    main { position: relative; overflow: hidden; background:#111; }

    .viewport { position: relative; width: 100%; height: 100%; overflow:hidden; cursor: grab; }
    .viewport.is-panning { cursor: grabbing; }
    .canvas-wrap { position:absolute; inset:0; transform-origin: 0 0; }
    .canvas-wrap img { display:block; max-width:none; user-select:none; }
    .svg-overlay { position:absolute; inset:0; pointer-events:none; }

    h1 { font-size: 16px; margin: 0 0 6px; color: var(--accent); }
    h2 { font-size: 13px; margin: 14px 0 6px; color: var(--accent); }
    label { display:block; font-size: 12px; margin: 8px 0 4px; }
    input[type="text"], input[type="number"], input[type="file"], textarea { width: 100%; padding: 8px; border:1px solid #ccc; border-radius:8px; font-size: 13px; }
    input[type="checkbox"] { transform: translateY(1px); }
    .row { display:flex; gap: 8px; }
    .row > * { flex: 1; }
    button { padding: 8px 10px; border:1px solid #bbb; background:#f8f8f8; border-radius:10px; cursor:pointer; font-size: 13px; }
    button.primary { background:#222; color:#fff; border-color:#222; }
    button.warn { background:#fff3f3; border-color:#dd7777; color:#b10000; }
    .muted { color:#666; font-size: 12px; }
    .toolbar { display:flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .stack { display:flex; flex-direction:column; gap:6px; }
    .palette { margin-top: 10px; display:flex; gap:10px; align-items:center; }
    .draggable-chip { padding:8px 12px; border:1px dashed #666; border-radius:16px; background:#fff; font-size:12px; cursor:grab; user-select:none; }
    .draggable-chip:active { cursor:grabbing; }
    details.advanced { margin-top: 16px; border:1px solid #d6d9dd; border-radius:10px; padding:10px 12px; background:#f9fafc; }
    details.advanced summary { cursor:pointer; font-weight:600; font-size:13px; color:var(--accent); }
    .advanced-controls { margin-top: 10px; display:grid; gap:10px; }
    .advanced-controls .row { gap:6px; }
    .advanced-controls label { font-size:12px; margin:0; }
    .advanced-controls label.inline { display:flex; align-items:center; gap:6px; }
    .advanced-controls label.inline input[type="checkbox"] { width:auto; }
    .advanced-controls input[type="number"] { width:100%; }
    .advanced-controls button { align-self:start; }
    .viewport.droppable::after {
      content:'Drop label onto map';
      position:absolute;
      inset:12px;
      border:2px dashed rgba(255,255,255,0.6);
      border-radius:12px;
      color:#fff;
      font-size:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      background:rgba(0,0,0,0.25);
    }

    /* Label visuals */
    .label { pointer-events: all; cursor: pointer; }
    .label rect { fill: rgba(255,255,255,0.8); stroke:#111; stroke-width:0.75; rx:4; ry:4; }
    .label text { font-family: ui-sans-serif, system-ui, -apple-system; line-height:1.1; fill:#111; dominant-baseline: middle; text-anchor: middle; }
    .label .hexid { font-size: 10px; fill:#444; }

    .grid-cell { fill: none; stroke: rgba(0,0,0,0.25); stroke-width:1; pointer-events:none; }
    .grid-label { font-family: ui-sans-serif, system-ui, -apple-system; font-size:11px; fill:rgba(0,0,0,0.4); pointer-events:none; }

    .hint { background:#f6f7f9; border:1px dashed #cfd6e0; padding:8px; border-radius:8px; font-size:12px; }
    .kbd { padding:0 6px; border:1px solid #aaa; border-bottom-width:2px; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#fff; font-size:11px; }

    /* Modal */
    dialog { border:none; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.25); padding: 0; }
    .modal { padding: 16px; min-width: 340px; }
    .modal h3 { margin: 0 0 8px; font-size: 15px; }
    .modal .actions { display:flex; gap:8px; justify-content:flex-end; margin-top: 10px; }
  </style>
</head>
<body>
  <aside>
    <h1>Hex Labeler</h1>

    <div class="hint">
      Click the map or drag the "Drag to add label" chip onto a hex â€” it will snap to the detected grid.
      Edit the details and repeat. Your work is saved automatically in localStorage. Scroll to zoom and drag the map background
      to pan.

    </div>

    <h2>Project</h2>
    <label>Map ID (used for saving)
      <input id="mapId" type="text" placeholder="e.g. dolmenwood" value="dolmenwood" />
    </label>
    <div class="toolbar">
      <button id="exportBtn">Export JSON</button>
      <button id="importBtn">Import JSON</button>
    </div>

    <div class="palette">
      <div id="newLabelChip" class="draggable-chip" draggable="true">Drag to add label</div>
    </div>
    <p class="muted">Tip: Edit a label by clicking it. Delete with the Delete key or the button in the editor.
      Hold <span class="kbd">Shift</span> while clicking to duplicate a label.</p>

    <details class="advanced" id="advancedTools">
      <summary>Advanced tools</summary>
      <div class="advanced-controls">
        <label class="inline">
          <input id="showGridToggle" type="checkbox" checked />
          Show grid overlay
        </label>
        <label>Grid scale (%)
          <input id="gridScale" type="number" min="10" max="400" step="1" value="90" />
        </label>
        <div class="row">
          <label>Offset X (px)
            <input id="gridOffsetX" type="number" step="1" value="214" />
          </label>
          <label>Offset Y (px)
            <input id="gridOffsetY" type="number" step="1" value="120" />
          </label>
        </div>
        <button type="button" id="resetGridAdjust">Reset grid adjustments</button>
        <p class="muted">Use these controls to align the overlay grid with the underlying map art. Scale adjusts hex size; offsets move the grid.</p>
      </div>
    </details>
  </aside>

  <main>
    <div id="viewport" class="viewport">
      <div id="canvasWrap" class="canvas-wrap">
        <img id="mapImg" alt="Map" />
        <svg id="overlay" class="svg-overlay"></svg>
      </div>
    </div>
  </main>

  <!-- Label editor modal -->
  <dialog id="dlg">
    <form method="dialog" class="modal" id="labelForm">
      <h3>Label</h3>
      <div class="row">
        <label>Hex ID
          <input id="f_hex" type="text" placeholder="e.g. 0805" />
        </label>
        <label>X, Y
          <input id="f_xy" type="text" readonly />
        </label>
      </div>
      <label>Text
        <textarea id="f_text" rows="3" placeholder="Label text..."></textarea>
      </label>
      <div class="actions">
        <button value="cancel">Cancel</button>
        <button id="delBtn" type="button" class="warn">Delete</button>
        <button id="okBtn" class="primary" value="ok">Save</button>
      </div>
    </form>
  </dialog>

  <script>
    // Optional: override the default Firebase database settings before this script runs by defining
    // `window.HEX_LABELER_FIREBASE_CONFIG = { databaseURL: "https://<your-project>.firebasedatabase.app", authToken?: "<optional-token>" }`.
    // --- Utility: localStorage persistence
    const storageKey = (id) => `hexlabeler:${id}`;
    const remoteSync = createRemoteSync();

    function saveStateLocal(id, data) {
      try {
        localStorage.setItem(storageKey(id), JSON.stringify(data));
      } catch (err) {
        console.warn('Failed to persist state locally', err);
      }
    }

    function loadStateLocal(id) {
      const raw = localStorage.getItem(storageKey(id));
      if (!raw) return null;
      try {
        return JSON.parse(raw);
      } catch (err) {
        console.warn('Failed to parse saved state', err);
        return null;
      }
    }

    function sanitizeImageSrc(src) {
      if (!src) return src;
      if (/^file:/i.test(src)) {
        const parts = src.split(/[\\\/]/);
        const filename = parts[parts.length - 1];
        return filename || null;
      }
      return src;
    }

    async function applyLoadedState(state, id) {
      labels = Array.isArray(state.labels) ? state.labels : [];
      applyOptions(state.options || {});
      const desiredImage = sanitizeImageSrc(state.imgMeta?.src);
      if (desiredImage && desiredImage !== mapImg.src) {
        try {
          await setImage(desiredImage);
        } catch (err) {
          console.warn('Failed to load remote image, continuing with current map', err);
          draw();
        }
      } else {
        draw();
      }
      const snapshot = {
        labels,
        options: currentOptions(),
        imgMeta: state.imgMeta || currentImageMeta()
      };
      saveStateLocal(id, snapshot);
    }

    async function loadState({ preferRemote = true } = {}) {
      const id = mapId.value.trim() || 'default';
      if (preferRemote) {
        const remote = await remoteSync.load(id);
        if (remote) {
          await applyLoadedState(remote, id);
          return true;
        }
      }
      const local = loadStateLocal(id);
      if (local) {
        await applyLoadedState(local, id);
        return true;
      }
      labels = [];
      draw();
      return false;
    }

    function saveState() {
      const id = mapId.value.trim() || 'default';
      const data = { labels, options: currentOptions(), imgMeta: currentImageMeta() };
      saveStateLocal(id, data);
      remoteSync.queueSave(id, data);
    }

    function createRemoteSync() {
      const firebaseConfig = (() => {
        const override = window.HEX_LABELER_FIREBASE_CONFIG;
        if (override && typeof override === 'object' && override.databaseURL) {
          return {
            baseUrl: String(override.databaseURL).replace(/\/$/, ''),
            authToken: override.authToken ? String(override.authToken) : null
          };
        }
        return {
          baseUrl: 'https://osr-hex-default-rtdb.europe-west1.firebasedatabase.app',
          authToken: null
        };
      })();

      if (!firebaseConfig || !firebaseConfig.baseUrl) {
        console.warn('Remote sync disabled: no Firebase Realtime Database URL configured.');
        return {
          queueSave() {},
          async load() { return null; }
        };
      }

      function buildUrl(id) {
        const encoded = encodeURIComponent(id);
        let url = `${firebaseConfig.baseUrl}/maps/${encoded}.json`;
        if (firebaseConfig.authToken) {
          const separator = url.includes('?') ? '&' : '?';
          url = `${url}${separator}auth=${encodeURIComponent(firebaseConfig.authToken)}`;
        }
        return url;
      }

      let pending = null;
      let timer = null;

      async function pushUpdate() {
        if (!pending) return;
        const { id, payload } = pending;
        pending = null;
        timer = null;
        try {
          const url = buildUrl(id);
          const body = JSON.stringify({
            ...payload,
            mapId: id,
            updatedAt: new Date().toISOString()
          });
          const res = await fetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body
          });
          if (!res.ok) {
            throw new Error(`Firebase responded with ${res.status}`);
          }
        } catch (err) {
          console.warn('Failed to sync map to Firebase', err);
        }
      }

      return {
        queueSave(id, payload) {
          pending = { id, payload };
          if (timer) clearTimeout(timer);
          timer = setTimeout(pushUpdate, 600);
        },
        async load(id) {
          try {
            const url = buildUrl(id);
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) {
              if (res.status === 401 || res.status === 403) {
                console.warn('Firebase denied access to map data. Check your database rules or auth token.');
              }
              throw new Error(`Firebase responded with ${res.status}`);
            }
            const data = await res.json();
            if (!data) return null;
            return data;
          } catch (err) {
            console.warn('Failed to load map from Firebase', err);
            return null;
          }
        }
      };
    }

    function currentImageMeta() {
      const img = mapImg;
      const rawSrc = img.getAttribute('src') || img.src;
      return { naturalWidth: img.naturalWidth, naturalHeight: img.naturalHeight, src: sanitizeImageSrc(rawSrc) };
    }

    // --- DOM refs
    const mapId = document.getElementById('mapId');
    const mapImg = document.getElementById('mapImg');
    const overlay = document.getElementById('overlay');
    const viewport = document.getElementById('viewport');
    const canvasWrap = document.getElementById('canvasWrap');

    // Controls
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');

    const FIXED_FONT_SIZE = 36;
    const FIXED_PADDING = 0;
    let showGrid = true;

    // Modal
    const dlg = document.getElementById('dlg');
    const f_hex = document.getElementById('f_hex');
    const f_xy = document.getElementById('f_xy');
    const f_text = document.getElementById('f_text');
    const delBtn = document.getElementById('delBtn');

    let labels = []; // {id, x, y, text, hex}
    let selectedId = null;
    let gridBase = null;
    let gridInfo = null;
    const DEFAULT_GRID_ADJUST = { scale: 90, offsetX: 214, offsetY: 120 };
    let gridAdjust = { ...DEFAULT_GRID_ADJUST };

    const showGridToggle = document.getElementById('showGridToggle');
    const gridScaleInput = document.getElementById('gridScale');
    const gridOffsetXInput = document.getElementById('gridOffsetX');
    const gridOffsetYInput = document.getElementById('gridOffsetY');
    const resetGridBtn = document.getElementById('resetGridAdjust');

    const viewState = { scale: 1, x: 0, y: 0 };

    // --- Image loading
    function setImage(src) {
      return new Promise((resolve, reject) => {
        mapImg.onload = () => { sizeOverlay(); analyzeImage().then(() => { fitToWindow(); draw(); }).finally(resolve); };
        mapImg.onerror = (e) => reject(e);
        mapImg.src = src;
      });
    }

    // --- Export/Import
    exportBtn.addEventListener('click', () => {
      const data = { labels, options: currentOptions(), img: currentImageMeta() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${mapId.value || 'labels'}.json`;
      a.click();
    });

    importBtn.addEventListener('click', async () => {
      const inp = document.createElement('input');
      inp.type = 'file'; inp.accept = 'application/json';
      inp.onchange = async () => {
        const f = inp.files?.[0]; if (!f) return;
        const text = await f.text();
        try {
          const data = JSON.parse(text);
          labels = data.labels || [];
          applyOptions(data.options || {});
          draw(); saveState();
        } catch(err) { alert('Invalid JSON'); }
      };
      inp.click();
    });

    // --- Grid helpers
    function currentOptions() {
      return {
        showGrid,
        fontSize: FIXED_FONT_SIZE,
        padding: FIXED_PADDING,
        gridAdjust: { ...gridAdjust }
      };
    }

    function applyOptions(opts) {
      showGrid = opts.showGrid !== false;
      if (showGridToggle) showGridToggle.checked = showGrid;
      const adj = opts.gridAdjust || {};
      gridAdjust.scale = Number.isFinite(adj.scale) ? clamp(adj.scale, 10, 400) : DEFAULT_GRID_ADJUST.scale;
      gridAdjust.offsetX = Number.isFinite(adj.offsetX) ? adj.offsetX : DEFAULT_GRID_ADJUST.offsetX;
      gridAdjust.offsetY = Number.isFinite(adj.offsetY) ? adj.offsetY : DEFAULT_GRID_ADJUST.offsetY;
      if (gridScaleInput) gridScaleInput.value = gridAdjust.scale;
      if (gridOffsetXInput) gridOffsetXInput.value = gridAdjust.offsetX;
      if (gridOffsetYInput) gridOffsetYInput.value = gridAdjust.offsetY;
      applyGridAdjustments();
      draw();
    }

    function applyGridAdjustments() {
      if (!gridBase) { gridInfo = null; return; }
      const scale = (gridAdjust.scale || DEFAULT_GRID_ADJUST.scale) / 100;
      const radius = gridBase.radius * scale;
      const hexHeight = Math.sqrt(3) * radius;
      const firstX = gridBase.firstX + gridAdjust.offsetX;
      const firstY = gridBase.firstY + gridAdjust.offsetY;
      const cells = [];
      for (let col = 0; col < gridBase.cols; col++) {
        const baseX = firstX + col * (1.5 * radius);
        const offsetY = (col % 2 === 0) ? 0 : hexHeight / 2;
        for (let row = 0; row < gridBase.rows; row++) {
          const cy = firstY + row * hexHeight + offsetY;
          const id = `${String(col + 1).padStart(2, '0')}${String(row + 1).padStart(2, '0')}`;
          cells.push({ id, col, row, x: baseX, y: cy });
        }
      }
      gridInfo = { ...gridBase, radius, hexHeight, cells };
    }

    // Draw grid visualization
    function drawGrid() {
      if (!showGrid || !gridInfo) return '';
      const pieces = [];
      const { cells, radius } = gridInfo;
      for (const cell of cells) {
        pieces.push(`<path class="grid-cell" d="${hexPath(cell.x, cell.y, radius)}" />`);
      }
      for (const cell of cells) {
        pieces.push(`<text class="grid-label" x="${cell.x}" y="${cell.y+4}">${cell.id}</text>`);
      }
      return pieces.join('');
    }

    // --- Coordinate helpers (image space)
    function clientToImageXY(evt) {
      const rect = mapImg.getBoundingClientRect();
      const scaleX = mapImg.naturalWidth / rect.width;
      const scaleY = mapImg.naturalHeight / rect.height;
      const x = (evt.clientX - rect.left) * scaleX;
      const y = (evt.clientY - rect.top) * scaleY;
      return [x, y];
    }

    function sizeOverlay() {
      overlay.setAttribute('viewBox', `0 0 ${mapImg.naturalWidth} ${mapImg.naturalHeight}`);
      overlay.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      canvasWrap.style.width = `${mapImg.naturalWidth}px`;
      canvasWrap.style.height = `${mapImg.naturalHeight}px`;
    }

    // --- Label rendering
    function draw() {
      const fs = FIXED_FONT_SIZE; const padding = FIXED_PADDING;
      const items = labels.map(l => labelNode(l, fs, padding)).join('');
      const gridSvg = drawGrid();
      overlay.innerHTML = `<g id="grid">${gridSvg}</g><g id="labels">${items}</g>`;
      // reattach events for labels
      overlay.querySelectorAll('.label').forEach(g => {
        g.addEventListener('click', (e) => { e.stopPropagation(); openEditor(g.dataset.id); });
      });
      overlay.style.pointerEvents = 'auto';
    }

    function labelNode(l, fs, padding) {
      const tid = (l.hex || '').trim();
      const textLines = (l.text || '').split('\n');
      const lineHeight = fs + 2;
      const width = Math.max(40, ...textLines.map(s => s.length * (fs * 0.6))) + padding*2;
      const height = lineHeight * textLines.length + (tid ? 12 : 0) + padding*2;
      const x = l.x - width/2; const y = l.y - height/2;
      const lines = textLines.map((s,i)=>`<text x="${l.x}" y="${y + padding + lineHeight/2 + i*lineHeight}" font-size="${fs}">${escapeHtml(s)}</text>`).join('');
      const hexLine = tid ? `<text class="hexid" x="${l.x}" y="${y + height - padding - 6}" font-size="10">${escapeHtml(tid)}</text>` : '';
      return `<g class="label" data-id="${l.id}">
        <rect x="${x}" y="${y}" width="${width}" height="${height}" />
        ${lines}
        ${hexLine}
      </g>`;
    }

    function escapeHtml(s){
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }

    // --- Interactions
    overlay.addEventListener('click', (e) => {
      if (isPanning) return;
      const [ix, iy] = clientToImageXY(e);
      const dupFrom = e.shiftKey ? labels.find(l => l.id === selectedId) : null;
      createLabelAt(ix, iy, { duplicateFrom: dupFrom });
    });

    function createLabelAt(ix, iy, { duplicateFrom = null } = {}) {
      const snap = snapToGrid(ix, iy);
      const x = snap ? snap.x : ix;
      const y = snap ? snap.y : iy;
      const newLabel = {
        id: crypto.randomUUID(),
        x,
        y,
        hex: snap ? snap.id : '',
        text: duplicateFrom ? duplicateFrom.text : ''
      };
      labels.push(newLabel);
      selectedId = newLabel.id;
      openEditor(newLabel.id, true);
      draw();
      saveState();
    }

    function openEditor(id, isNew = false) {
      selectedId = id;
      const l = labels.find(x => x.id === id); if (!l) return;
      f_hex.value = l.hex || '';
      f_xy.value = `${l.x.toFixed(1)}, ${l.y.toFixed(1)}`;
      f_text.value = l.text || '';
      delBtn.onclick = () => { if (confirm('Delete this label?')) { labels = labels.filter(x => x.id !== id); dlg.close(); draw(); saveState(); } };
      dlg.dataset.isNew = isNew ? '1' : '';
      dlg.showModal();
    }

    dlg.addEventListener('close', () => {
      const isNew = dlg.dataset.isNew === '1';
      if (dlg.returnValue !== 'ok') {
        if (isNew) {
          labels = labels.filter(x => x.id !== selectedId);
          selectedId = null;
          draw(); saveState();
        }
        return;
      }
      const l = labels.find(x => x.id === selectedId); if (!l) return;
      l.hex = f_hex.value.trim();
      l.text = f_text.value;
      draw(); saveState();
    });

    // Drag labels
    let draggingId = null;
    overlay.addEventListener('mousedown', (e) => {
      const target = e.target.closest('.label');
      if (!target) return;
      draggingId = target.dataset.id; selectedId = draggingId;
      const [startX, startY] = clientToImageXY(e);
      const l = labels.find(x => x.id === draggingId);
      const ox = l.x - startX, oy = l.y - startY;
      function move(ev){
        const [mx, my] = clientToImageXY(ev);
        let nx = mx + ox, ny = my + oy;
        const snap = snapToGrid(nx, ny);
        if (snap) { l.x = snap.x; l.y = snap.y; l.hex = snap.id; }
        else { l.x = nx; l.y = ny; }
        draw();
      }
      function up(){ window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up); saveState(); }
      window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
    });

    // Keyboard delete
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Delete' && selectedId) { labels = labels.filter(l => l.id !== selectedId); selectedId = null; draw(); saveState(); }
    });

    // Persist UI -> redraw
    mapId.addEventListener('change', async () => {
      const found = await loadState({ preferRemote: true });
      if (!found) {
        labels = [];
        draw();
        saveState();
      }
    });

    // Initial image: try to preload the provided path if available
    (async function init(){
      draw();
      // Attempt to load the bundled Dolmenwood map by default. Fallback to any saved state if loading fails.
      try {
        await setImage('Dolmenwood_Blank_Hex_Map.png');
      } catch(err) {
        console.warn('Failed to load bundled map image:', err);
      }
      // Attempt to load any saved state for default project
      const loaded = await loadState({ preferRemote: true });
      if (!loaded) {
        saveState();
      }
    })();

    // --- Grid analysis
    const gridPresets = {
      'dolmenwood_blank_hex_map.png': { cols: 19, rows: 12 }
    };

    async function analyzeImage() {
      const w = mapImg.naturalWidth, h = mapImg.naturalHeight;
      if (!w || !h) { gridBase = null; gridInfo = null; return; }
      const canvas = document.createElement('canvas');
      const maxDim = 1000;
      const scale = Math.min(1, maxDim / Math.max(w, h));
      const sw = Math.max(1, Math.round(w * scale));
      const sh = Math.max(1, Math.round(h * scale));
      canvas.width = sw; canvas.height = sh;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(mapImg, 0, 0, sw, sh);
      let data;
      try {
        data = ctx.getImageData(0, 0, sw, sh).data;
      } catch(err) {
        console.warn('Unable to analyze grid from image', err);
        gridBase = null;
        gridInfo = null;
        return;
      }
      let minX = sw, minY = sh, maxX = 0, maxY = 0;
      for (let y = 0; y < sh; y++) {
        for (let x = 0; x < sw; x++) {
          const idx = (y * sw + x) * 4;
          const r = data[idx], g = data[idx+1], b = data[idx+2];
          if (r < 245 || g < 245 || b < 245) {
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }
        }
      }
      if (minX > maxX || minY > maxY) {
        gridBase = null;
        gridInfo = null;
        return;
      }
      const bounds = {
        left: minX / scale,
        top: minY / scale,
        right: (maxX + 1) / scale,
        bottom: (maxY + 1) / scale
      };
      const fileName = (mapImg.src.split('/').pop() || '').toLowerCase();
      const preset = gridPresets[fileName] || { cols: 19, rows: 12 };
      const width = bounds.right - bounds.left;
      const height = bounds.bottom - bounds.top;
      const rW = width / (1.5 * (preset.cols - 1) + 2);
      const rH = (height / preset.rows) / Math.sqrt(3);
      const radius = (rW + rH) / 2;
      const hexHeight = Math.sqrt(3) * radius;
      const firstX = bounds.left + radius;
      const firstY = bounds.top + hexHeight / 2;
      gridBase = {
        bounds,
        radius,
        hexHeight,
        cols: preset.cols,
        rows: preset.rows,
        firstX,
        firstY
      };
      applyGridAdjustments();
    }

    function hexPath(cx, cy, r) {
      const pts = [];
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i);
        const px = cx + r * Math.cos(angle);
        const py = cy + r * Math.sin(angle);
        pts.push(`${px},${py}`);
      }
      return `M${pts.join(' L')} Z`;
    }

    function snapToGrid(x, y) {
      if (!gridInfo) return null;
      let best = null; let bestDist = Infinity;
      for (const cell of gridInfo.cells) {
        const dx = cell.x - x;
        const dy = cell.y - y;
        const dist = dx*dx + dy*dy;
        if (dist < bestDist) { bestDist = dist; best = cell; }
      }
      if (!best) return null;
      return { ...best };
    }

    // --- Zoom & pan
    let isPanning = false;
    let panPointer = null;
    let panStart = null;

    viewport.addEventListener('pointerdown', (evt) => {
      if (evt.button !== 0) return;
      const target = evt.target;
      if (target.closest('svg') && target.closest('.label')) return; // let label dragging handle it
      isPanning = true;
      panPointer = evt.pointerId;
      panStart = { x: evt.clientX - viewState.x, y: evt.clientY - viewState.y };
      viewport.classList.add('is-panning');
      if (viewport.setPointerCapture) viewport.setPointerCapture(evt.pointerId);
    });

    viewport.addEventListener('pointermove', (evt) => {
      if (!isPanning || evt.pointerId !== panPointer) return;
      viewState.x = evt.clientX - panStart.x;
      viewState.y = evt.clientY - panStart.y;
      applyView();
    });

    viewport.addEventListener('pointerup', endPan);
    viewport.addEventListener('pointercancel', endPan);

    function endPan(evt) {
      if (!isPanning || evt.pointerId !== panPointer) return;
      isPanning = false;
      panPointer = null;
      viewport.classList.remove('is-panning');
      if (viewport.hasPointerCapture && viewport.hasPointerCapture(evt.pointerId)) {
        viewport.releasePointerCapture(evt.pointerId);
      }
    }

    viewport.addEventListener('wheel', (evt) => {
      evt.preventDefault();
      const scaleFactor = Math.exp(-evt.deltaY * 0.0015);
      const newScale = clamp(viewState.scale * scaleFactor, 0.25, 4);
      const rect = viewport.getBoundingClientRect();
      const offsetX = evt.clientX - rect.left;
      const offsetY = evt.clientY - rect.top;
      const dx = offsetX - viewState.x;
      const dy = offsetY - viewState.y;
      const ratio = newScale / viewState.scale;
      viewState.x = offsetX - dx * ratio;
      viewState.y = offsetY - dy * ratio;
      viewState.scale = newScale;
      applyView();
    }, { passive: false });

    function applyView() {
      canvasWrap.style.transform = `translate(${viewState.x}px, ${viewState.y}px) scale(${viewState.scale})`;
    }

    function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

    function resetGridAdjustments() {
      gridAdjust = { ...DEFAULT_GRID_ADJUST };
      if (gridScaleInput) gridScaleInput.value = gridAdjust.scale;
      if (gridOffsetXInput) gridOffsetXInput.value = gridAdjust.offsetX;
      if (gridOffsetYInput) gridOffsetYInput.value = gridAdjust.offsetY;
      applyGridAdjustments();
      draw();
      saveState();
    }

    if (showGridToggle) {
      showGridToggle.addEventListener('change', () => {
        showGrid = showGridToggle.checked;
        draw();
        saveState();
      });
    }

    if (gridScaleInput && gridOffsetXInput && gridOffsetYInput && resetGridBtn) {
      gridScaleInput.addEventListener('change', () => {
        const value = parseFloat(gridScaleInput.value);
        gridAdjust.scale = Number.isFinite(value) ? clamp(value, 10, 400) : DEFAULT_GRID_ADJUST.scale;
        gridScaleInput.value = gridAdjust.scale;
        applyGridAdjustments();
        draw();
        saveState();
      });
      const handleOffsetChange = () => {
        const offX = parseFloat(gridOffsetXInput.value);
        const offY = parseFloat(gridOffsetYInput.value);
        gridAdjust.offsetX = Number.isFinite(offX) ? offX : DEFAULT_GRID_ADJUST.offsetX;
        gridAdjust.offsetY = Number.isFinite(offY) ? offY : DEFAULT_GRID_ADJUST.offsetY;
        applyGridAdjustments();
        draw();
        saveState();
      };
      gridOffsetXInput.addEventListener('change', handleOffsetChange);
      gridOffsetYInput.addEventListener('change', handleOffsetChange);
      resetGridBtn.addEventListener('click', resetGridAdjustments);
    }

    function fitToWindow(animated = false) {
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;
      if (!mapImg.naturalWidth || !mapImg.naturalHeight) return;
      const scale = Math.min(vw / mapImg.naturalWidth, vh / mapImg.naturalHeight) || 1;
      const newX = (vw - mapImg.naturalWidth * scale) / 2;
      const newY = (vh - mapImg.naturalHeight * scale) / 2;
      viewState.scale = scale;
      viewState.x = newX;
      viewState.y = newY;
      if (animated) {
        canvasWrap.style.transition = 'transform 0.2s ease';
        requestAnimationFrame(() => {
          applyView();
          setTimeout(() => { canvasWrap.style.transition = ''; }, 200);
        });
      } else {
        applyView();
      }
    }

    // Drag-and-drop label creation
    const newLabelChip = document.getElementById('newLabelChip');
    newLabelChip.addEventListener('dragstart', (evt) => {
      evt.dataTransfer.effectAllowed = 'copy';
      evt.dataTransfer.setData('application/x-hexlabel', 'new');
      viewport.classList.add('droppable');
    });

    newLabelChip.addEventListener('dragend', () => {
      viewport.classList.remove('droppable');
    });

    function allowLabelDrop(evt) {
      if (!evt.dataTransfer) return;
      if (evt.dataTransfer.types.includes('application/x-hexlabel')) {
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy';
      }
    }

    viewport.addEventListener('dragover', allowLabelDrop);
    viewport.addEventListener('dragenter', allowLabelDrop);
    viewport.addEventListener('dragleave', (evt) => {
      if (evt.relatedTarget && viewport.contains(evt.relatedTarget)) return;
      viewport.classList.remove('droppable');
    });

    viewport.addEventListener('drop', (evt) => {
      if (!evt.dataTransfer) return;
      const marker = evt.dataTransfer.getData('application/x-hexlabel');
      viewport.classList.remove('droppable');
      if (marker !== 'new') return;
      evt.preventDefault();
      const rect = mapImg.getBoundingClientRect();
      if (evt.clientX < rect.left || evt.clientX > rect.right || evt.clientY < rect.top || evt.clientY > rect.bottom) {
        return;
      }
      const [ix, iy] = clientToImageXY(evt);
      createLabelAt(ix, iy);
    });
  </script>
</body>
</html>
