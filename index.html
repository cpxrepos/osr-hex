<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hex Labeler</title>
  <style>
    :root { --panel-w: 340px; --accent: #222; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    body { display: grid; grid-template-columns: var(--panel-w) 1fr; gap: 0; }
    aside { padding: 14px 14px 18px; border-right: 1px solid #ddd; overflow:auto; }
    .label-list-panel { margin-top: 18px; display:flex; flex-direction:column; gap:8px; }
    .label-list-header { display:flex; align-items:center; gap:10px; }
    .label-list-header h2 { margin:0; flex:0 0 auto; }
    #labelFilter { flex:1; min-width:0; }
    #labelList { max-height: 260px; overflow:auto; border:1px solid #d6d9dd; border-radius:10px; background:#fff; padding:4px; display:flex; flex-direction:column; gap:4px; }
    .label-list-item { display:flex; align-items:center; gap:10px; width:100%; padding:8px 10px; border:none; background:transparent; border-radius:8px; cursor:pointer; text-align:left; font-size:12px; transition:background 0.15s ease; }
    .label-list-item:hover { background:#eef1f7; }
    .label-list-item.is-active { background:#dfe7ff; }
    .label-list-hex { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-weight:600; color:#333; min-width:3.5em; }
    .label-list-title { flex:1; min-width:0; color:#222; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .label-list-kind { font-size:11px; color:#5a6270; text-transform:uppercase; letter-spacing:0.06em; }
    .label-list-empty { padding:14px 12px; text-align:center; font-size:12px; color:#666; }
    main { position: relative; overflow: hidden; background:#111; }

    .viewport { position: relative; width: 100%; height: 100%; overflow:hidden; cursor: grab; }
    .viewport.is-panning { cursor: grabbing; }
    .canvas-wrap { position:absolute; inset:0; transform-origin: 0 0; }
    .canvas-wrap img { display:block; max-width:none; user-select:none; }
    .svg-overlay { position:absolute; inset:0; pointer-events:none; }

    h1 { font-size: 16px; margin: 0 0 6px; color: var(--accent); }
    h2 { font-size: 13px; margin: 14px 0 6px; color: var(--accent); }
    label { display:block; font-size: 12px; margin: 8px 0 4px; }
    input[type="text"], input[type="number"], input[type="file"], textarea { width: 100%; padding: 8px; border:1px solid #ccc; border-radius:8px; font-size: 13px; }
    input[type="checkbox"] { transform: translateY(1px); }
    .row { display:flex; gap: 8px; }
    .row > * { flex: 1; }
    button { padding: 8px 10px; border:1px solid #bbb; background:#f8f8f8; border-radius:10px; cursor:pointer; font-size: 13px; }
    button.primary { background:#222; color:#fff; border-color:#222; }
    button.warn { background:#fff3f3; border-color:#dd7777; color:#b10000; }
    .muted { color:#666; font-size: 12px; }
    .toolbar { display:flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .stack { display:flex; flex-direction:column; gap:6px; }
    .palette { margin-top: 10px; display:flex; gap:10px; align-items:center; }
    .draggable-chip { padding:8px 12px; border:1px dashed #666; border-radius:16px; background:#fff; font-size:12px; cursor:grab; user-select:none; }
    .draggable-chip:active { cursor:grabbing; }
    .icon-palette { display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; }
    .icon-chip { width:64px; height:64px; border:1px dashed #666; border-radius:12px; display:flex; align-items:center; justify-content:center; background:#fff; cursor:grab; }
    .icon-chip svg { width:42px; height:42px; }
    .icon-chip:active { cursor:grabbing; }

    .map-item { pointer-events: all; cursor: pointer; }
    details.advanced { margin-top: 16px; border:1px solid #d6d9dd; border-radius:10px; padding:10px 12px; background:#f9fafc; }
    details.advanced summary { cursor:pointer; font-weight:600; font-size:13px; color:var(--accent); }
    .advanced-controls { margin-top: 10px; display:grid; gap:10px; }
    .advanced-controls .row { gap:6px; }
    .advanced-controls label { font-size:12px; margin:0; }

    .advanced-controls label.inline { display:flex; align-items:center; gap:6px; }
    .advanced-controls label.inline input[type="checkbox"] { width:auto; }

    .advanced-controls input[type="number"] { width:100%; }
    .advanced-controls button { align-self:start; }
    .viewport.droppable::after {
      content:'Drop label onto map';
      position:absolute;
      inset:12px;
      border:2px dashed rgba(255,255,255,0.6);
      border-radius:12px;
      color:#fff;
      font-size:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      background:rgba(0,0,0,0.25);
    }

    /* Label visuals */
    .label rect { fill: rgba(255,255,255,0.8); stroke:#111; stroke-width:0.75; rx:4; ry:4; }
    .label text { font-family: ui-sans-serif, system-ui, -apple-system; line-height:1.1; fill:#111; dominant-baseline: middle; text-anchor: middle; }
    .label .hexid { font-size: 10px; fill:#444; }

    .icon path,
    .icon rect,
    .icon circle,
    .icon polygon,
    .icon polyline { fill:#1a1a1a; stroke:#f6f6f6; stroke-width:4; stroke-linecap:round; stroke-linejoin:round; }
    .icon { filter: drop-shadow(0 1px 0 rgba(255,255,255,0.35)) drop-shadow(0 3px 6px rgba(0,0,0,0.35)); }
    .icon text { font-family: ui-sans-serif, system-ui, -apple-system; text-anchor: middle; dominant-baseline: hanging; fill:#fff; stroke:#111; stroke-width:3; paint-order: stroke fill; }

    .grid-cell { fill: none; stroke: rgba(0,0,0,0.25); stroke-width:1; pointer-events:none; }
    .grid-label { font-family: ui-sans-serif, system-ui, -apple-system; font-size:11px; fill:rgba(0,0,0,0.4); pointer-events:none; }

    .hint { background:#f6f7f9; border:1px dashed #cfd6e0; padding:8px; border-radius:8px; font-size:12px; }
    .kbd { padding:0 6px; border:1px solid #aaa; border-bottom-width:2px; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#fff; font-size:11px; }

    /* Modal */
    dialog { border:none; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.25); padding: 0; }
    .modal { padding: 16px; min-width: 340px; }
    .modal h3 { margin: 0 0 8px; font-size: 15px; }
    .modal .actions { display:flex; gap:8px; justify-content:flex-end; margin-top: 10px; }
  </style>
</head>
<body>
  <aside>
    <h1>Hex Labeler</h1>

    <h2>Map ID (used for saving)</h2>
    <label>
      <input id="mapId" type="text" placeholder="e.g. dolmenwood" value="dolmenwood" />
    </label>
    <div class="toolbar">
      <button id="exportBtn">Export JSON</button>
      <button id="importBtn">Import JSON</button>
    </div>

    <div class="palette">
      <div id="newLabelChip" class="draggable-chip" draggable="true">Drag to add label</div>
    </div>
    <h2>Icons</h2>
    <div id="iconPalette" class="icon-palette" aria-label="Icon palette"></div>
    <p class="muted">Tip: Drag the "Drag to add label" chip onto a hex â€” it will snap to the detected grid.
      Edit the details and repeat. You can also drag one of the icons onto the map for quick castle, town,
      cave, or road markers. Scroll to zoom and drag the map background
      to pan. Edit a label or icon by clicking it. Delete with the Delete key or the button in the editor.
      </p>

    <details class="advanced" id="advancedTools">
      <summary>Advanced tools</summary>
      <div class="advanced-controls">

        <label class="inline">
          <input id="showGridToggle" type="checkbox" checked />
          Show grid overlay
        </label>
        <label>Grid scale (%)
          <input id="gridScale" type="number" min="10" max="400" step="1" value="90" />
        </label>
        <div class="row">
          <label>Offset X (px)
            <input id="gridOffsetX" type="number" step="1" value="214" />
          </label>
          <label>Offset Y (px)
            <input id="gridOffsetY" type="number" step="1" value="120" />

          </label>
        </div>
        <button type="button" id="resetGridAdjust">Reset grid adjustments</button>
        <p class="muted">Use these controls to align the overlay grid with the underlying map art. Scale adjusts hex size; offsets move the grid.</p>
      </div>
    </details>

    <div class="label-list-panel">
      <div class="label-list-header">
        <h2>Labels</h2>
        <input id="labelFilter" type="text" placeholder="Filter labels..." aria-label="Filter labels" />
      </div>
      <div id="labelList" role="listbox" aria-label="Map labels"></div>
    </div>
  </aside>

  <main>
    <div id="viewport" class="viewport">
      <div id="canvasWrap" class="canvas-wrap">
        <img id="mapImg" alt="Map" />
        <svg id="overlay" class="svg-overlay"></svg>
      </div>
    </div>
  </main>

  <!-- Label editor modal -->
  <dialog id="dlg">
    <form method="dialog" class="modal" id="labelForm">
      <h3>Label</h3>
      <div class="row">
        <label>Hex ID
          <input id="f_hex" type="text" placeholder="e.g. 0805" />
        </label>
        <label>X, Y
          <input id="f_xy" type="text" readonly />
        </label>
      </div>
      <label>Type
        <select id="f_kind">
          <option value="text">Text label</option>
          <option value="icon">Icon</option>
        </select>
      </label>
      <label id="iconFieldWrap">Icon
        <select id="f_icon"></select>
      </label>
      <label id="textFieldWrap">Text
        <textarea id="f_text" rows="3" placeholder="Label text..."></textarea>
      </label>
      <div class="actions">
        <button value="cancel">Cancel</button>
        <button id="delBtn" type="button" class="warn">Delete</button>
        <button id="okBtn" class="primary" value="ok">Save</button>
      </div>
    </form>
  </dialog>

  <script>
    // Optional: override the default Firebase database settings before this script runs by defining
    // `window.HEX_LABELER_FIREBASE_CONFIG = { databaseURL: "https://<your-project>.firebasedatabase.app", authToken?: "<optional-token>" }`.
    // --- Utility: localStorage persistence
    const storageKey = (id) => `hexlabeler:${id}`;
    const remoteSync = createRemoteSync();

    function saveStateLocal(id, data) {
      try {
        localStorage.setItem(storageKey(id), JSON.stringify(data));
      } catch (err) {
        console.warn('Failed to persist state locally', err);
      }
    }

    function loadStateLocal(id) {
      const raw = localStorage.getItem(storageKey(id));
      if (!raw) return null;
      try {
        return JSON.parse(raw);
      } catch (err) {
        console.warn('Failed to parse saved state', err);
        return null;
      }
    }

    function sanitizeImageSrc(src) {
      if (!src) return src;
      if (/^file:/i.test(src)) {
        const parts = src.split(/[\\\/]/);
        const filename = parts[parts.length - 1];
        return filename || null;
      }
      return src;
    }

    async function applyLoadedState(state, id) {
      labels = Array.isArray(state.labels) ? state.labels.map(normalizeLabel).filter(Boolean) : [];
      applyOptions(state.options || {});
      const desiredImage = sanitizeImageSrc(state.imgMeta?.src);
      if (desiredImage && desiredImage !== mapImg.src) {
        try {
          await setImage(desiredImage);
        } catch (err) {
          console.warn('Failed to load remote image, continuing with current map', err);
          draw();
        }
      } else {
        draw();
      }
      const snapshot = {
        labels,
        options: currentOptions(),
        imgMeta: state.imgMeta || currentImageMeta()
      };
      saveStateLocal(id, snapshot);
    }

    async function loadState({ preferRemote = true } = {}) {
      const id = mapId.value.trim() || 'default';
      if (preferRemote) {
        const remote = await remoteSync.load(id);
        if (remote) {
          await applyLoadedState(remote, id);
          return true;
        }
      }
      const local = loadStateLocal(id);
      if (local) {
        await applyLoadedState(local, id);
        return true;
      }
      labels = [];
      draw();
      return false;
    }

    function saveState() {
      const id = mapId.value.trim() || 'default';
      const data = { labels, options: currentOptions(), imgMeta: currentImageMeta() };
      saveStateLocal(id, data);
      remoteSync.queueSave(id, data);
    }

    function createRemoteSync() {
      const firebaseConfig = (() => {
        const override = window.HEX_LABELER_FIREBASE_CONFIG;
        if (override && typeof override === 'object' && override.databaseURL) {
          return {
            baseUrl: String(override.databaseURL).replace(/\/$/, ''),
            authToken: override.authToken ? String(override.authToken) : null
          };
        }
        return {
          baseUrl: 'https://osr-hex-default-rtdb.europe-west1.firebasedatabase.app',
          authToken: null
        };
      })();

      if (!firebaseConfig || !firebaseConfig.baseUrl) {
        console.warn('Remote sync disabled: no Firebase Realtime Database URL configured.');
        return {
          queueSave() {},
          async load() { return null; }
        };
      }

      function buildUrl(id) {
        const encoded = encodeURIComponent(id);
        let url = `${firebaseConfig.baseUrl}/maps/${encoded}.json`;
        if (firebaseConfig.authToken) {
          const separator = url.includes('?') ? '&' : '?';
          url = `${url}${separator}auth=${encodeURIComponent(firebaseConfig.authToken)}`;
        }
        return url;
      }

      let pending = null;
      let timer = null;

      async function pushUpdate() {
        if (!pending) return;
        const { id, payload } = pending;
        pending = null;
        timer = null;
        try {
          const url = buildUrl(id);
          const body = JSON.stringify({
            ...payload,
            mapId: id,
            updatedAt: new Date().toISOString()
          });
          const res = await fetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body
          });
          if (!res.ok) {
            throw new Error(`Firebase responded with ${res.status}`);
          }
        } catch (err) {
          console.warn('Failed to sync map to Firebase', err);
        }
      }

      return {
        queueSave(id, payload) {
          pending = { id, payload };
          if (timer) clearTimeout(timer);
          timer = setTimeout(pushUpdate, 600);
        },
        async load(id) {
          try {
            const url = buildUrl(id);
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) {
              if (res.status === 401 || res.status === 403) {
                console.warn('Firebase denied access to map data. Check your database rules or auth token.');
              }
              throw new Error(`Firebase responded with ${res.status}`);
            }
            const data = await res.json();
            if (!data) return null;
            return data;
          } catch (err) {
            console.warn('Failed to load map from Firebase', err);
            return null;
          }
        }
      };
    }

    function currentImageMeta() {
      const img = mapImg;
      const rawSrc = img.getAttribute('src') || img.src;
      return { naturalWidth: img.naturalWidth, naturalHeight: img.naturalHeight, src: sanitizeImageSrc(rawSrc) };
    }

    // --- DOM refs
    const mapId = document.getElementById('mapId');
    const mapImg = document.getElementById('mapImg');
    const overlay = document.getElementById('overlay');
    const viewport = document.getElementById('viewport');
    const canvasWrap = document.getElementById('canvasWrap');
    const iconPalette = document.getElementById('iconPalette');
    const labelList = document.getElementById('labelList');
    const labelFilter = document.getElementById('labelFilter');

    // Controls
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');

    const FIXED_FONT_SIZE = 36;
    const FIXED_PADDING = 0;
    let showGrid = true;

    const ICONS = [
      {
        id: 'castle',
        label: 'Castle',
        svg: `
          <path d="M18 82V40h10V26h8v14h12V26h8v14h10v42H18z" />
          <path d="M34 82V58h32v24" />
          <rect x="44" y="58" width="12" height="24" rx="3" />
          <path d="M34 40h32" />
        `
      },
      {
        id: 'town',
        label: 'Town',
        svg: `
          <path d="M20 82V56l20-15 20 15v26H20z" />
          <rect x="36" y="66" width="10" height="16" rx="2" />
          <path d="M60 82V62l14-10 14 10v20H60z" />
          <rect x="72" y="68" width="8" height="14" rx="2" />
        `
      },
      {
        id: 'city',
        label: 'City',
        svg: `
          <path d="M16 82V48l10-6 10 6v34H16z" />
          <path d="M36 82V38l12-8 12 8v44H36z" />
          <path d="M60 82V54l10-6 10 6v28H60z" />
          <path d="M80 82V62l6-4 6 4v20H80z" />
          <rect x="44" y="60" width="8" height="22" rx="2" />
          <rect x="66" y="64" width="6" height="18" rx="2" />
        `
      },
      {
        id: 'cave',
        label: 'Cave',
        svg: `
          <path d="M18 82c0-28 14-46 32-46s32 18 32 46H18z" />
          <path d="M40 82c0-14 6-26 10-26s10 12 10 26" />
          <path d="M26 58l8-12 8 8" />
        `
      },
      {
        id: 'road',
        label: 'Road',
        svg: `
          <path d="M32 18c26 22 22 34 8 46s-10 26 10 44" />
          <path d="M50 18c26 20 22 32 10 44s-6 26 16 44" />
        `
      },
      {
        id: 'camp',
        label: 'Camp',
        svg: `
          <path d="M18 82l32-54 32 54H18z" />
          <path d="M50 34v48" />
          <path d="M34 62h20" />
        `
      }
    ];

    const ICON_LOOKUP = Object.fromEntries(ICONS.map(icon => [icon.id, icon]));

    // Modal
    const dlg = document.getElementById('dlg');
    const f_hex = document.getElementById('f_hex');
    const f_xy = document.getElementById('f_xy');
    const f_text = document.getElementById('f_text');
    const f_kind = document.getElementById('f_kind');
    const f_icon = document.getElementById('f_icon');
    const iconFieldWrap = document.getElementById('iconFieldWrap');
    const textFieldWrap = document.getElementById('textFieldWrap');
    const delBtn = document.getElementById('delBtn');

    let labels = []; // {id, x, y, text, hex, kind, iconId}
    let selectedId = null;
    let gridBase = null;
    let gridInfo = null;

    const DEFAULT_GRID_ADJUST = { scale: 90, offsetX: 214, offsetY: 120 };
    let gridAdjust = { ...DEFAULT_GRID_ADJUST };

    const showGridToggle = document.getElementById('showGridToggle');

    const gridScaleInput = document.getElementById('gridScale');
    const gridOffsetXInput = document.getElementById('gridOffsetX');
    const gridOffsetYInput = document.getElementById('gridOffsetY');
    const resetGridBtn = document.getElementById('resetGridAdjust');

    const viewState = { scale: 1, x: 0, y: 0 };

    if (iconPalette) {
      iconPalette.innerHTML = ICONS.map(icon => `<div class="icon-chip" draggable="true" data-icon="${icon.id}" title="${icon.label}">${iconSvgMarkup(icon.id)}</div>`).join('');
      iconPalette.querySelectorAll('.icon-chip').forEach(chip => {
        chip.addEventListener('dragstart', (evt) => {
          evt.dataTransfer.effectAllowed = 'copy';
          evt.dataTransfer.setData('application/x-hexlabel', `icon:${chip.dataset.icon}`);
          viewport.classList.add('droppable');
        });
        chip.addEventListener('dragend', () => {
          viewport.classList.remove('droppable');
        });
      });
    }

    if (labelFilter) {
      labelFilter.addEventListener('input', () => {
        renderLabelList();
      });
    }

    if (labelList) {
      labelList.addEventListener('click', (evt) => {
        const item = evt.target.closest('.label-list-item');
        if (!item) return;
        const id = item.dataset.id;
        const label = labels.find(x => x.id === id);
        if (!label) return;
        selectedId = id;
        renderLabelList();
        focusLabelOnMap(label);
        openEditor(id);
      });
    }

    renderLabelList();

    if (f_icon) {
      f_icon.innerHTML = ICONS.map(icon => `<option value="${icon.id}">${icon.label}</option>`).join('');
    }

    if (f_kind) {
      f_kind.addEventListener('change', () => {
        updateEditorMode(f_kind.value);
      });
    }

    updateEditorMode('text');

    function iconSvgMarkup(iconId) {
      const icon = ICON_LOOKUP[iconId] || ICONS[0];
      return `<svg viewBox="0 0 100 100" aria-hidden="true" focusable="false">${icon.svg}</svg>`;
    }

    function normalizeLabel(entry) {
      if (!entry || typeof entry !== 'object') {
        return null;
      }
      const kind = entry.kind === 'icon' ? 'icon' : 'text';
      const iconId = kind === 'icon' && ICON_LOOKUP[entry.iconId] ? entry.iconId : ICONS[0].id;
      const xVal = Number(entry.x);
      const yVal = Number(entry.y);
      return {
        id: entry.id || crypto.randomUUID(),
        kind,
        iconId,
        text: typeof entry.text === 'string' ? entry.text : '',
        x: Number.isFinite(xVal) ? xVal : 0,
        y: Number.isFinite(yVal) ? yVal : 0,
        hex: typeof entry.hex === 'string' ? entry.hex : ''
      };
    }

    function iconNode(l) {
      const icon = ICON_LOOKUP[l.iconId] || ICONS[0];
      const baseSize = gridInfo ? gridInfo.radius * 1.7 : 80;
      const size = Math.max(40, Math.min(baseSize, 120));
      const scale = size / 100;
      const rawLines = (l.text || '').split('\n');
      const hasContent = rawLines.some(line => line.trim().length > 0);
      const textLines = hasContent ? rawLines : [];
      const textMarkup = textLines.map((line, idx) => `
        <text class="icon-label" x="50" y="${110 + idx * 18}" font-size="18">${escapeHtml(line)}</text>
      `).join('');
      const yOffset = hasContent ? 104 : 54;
      return `<g class="map-item icon" data-id="${l.id}" data-icon="${icon.id}" transform="translate(${l.x},${l.y}) scale(${scale}) translate(-50,-${yOffset})">${icon.svg}${textMarkup}</g>`;
    }

    function updateEditorMode(mode) {
      const kind = mode === 'icon' ? 'icon' : 'text';
      if (f_kind && f_kind.value !== kind) {
        f_kind.value = kind;
      }
      if (iconFieldWrap) {
        iconFieldWrap.style.display = kind === 'icon' ? '' : 'none';
      }
      if (textFieldWrap) {
        textFieldWrap.style.display = '';
      }
      if (f_icon) {
        if (kind === 'icon' && !ICON_LOOKUP[f_icon.value]) {
          f_icon.value = ICONS[0].id;
        }
        f_icon.disabled = kind !== 'icon';
      }
      if (f_text) {
        f_text.disabled = false;
        f_text.placeholder = kind === 'icon' ? 'Optional text shown beneath the icon...' : 'Label text...';
      }
      dlg.dataset.kind = kind;
    }

    // --- Image loading
    function setImage(src) {
      return new Promise((resolve, reject) => {
        mapImg.onload = () => { sizeOverlay(); analyzeImage().then(() => { fitToWindow(); draw(); }).finally(resolve); };
        mapImg.onerror = (e) => reject(e);
        mapImg.src = src;
      });
    }

    // --- Export/Import
    exportBtn.addEventListener('click', () => {
      const data = { labels, options: currentOptions(), img: currentImageMeta() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${mapId.value || 'labels'}.json`;
      a.click();
    });

    importBtn.addEventListener('click', async () => {
      const inp = document.createElement('input');
      inp.type = 'file'; inp.accept = 'application/json';
      inp.onchange = async () => {
        const f = inp.files?.[0]; if (!f) return;
        const text = await f.text();
        try {
          const data = JSON.parse(text);
          labels = Array.isArray(data.labels) ? data.labels.map(normalizeLabel).filter(Boolean) : [];
          applyOptions(data.options || {});
          draw(); saveState();
          renderLabelList();
        } catch(err) { alert('Invalid JSON'); }
      };
      inp.click();
    });

    // --- Grid helpers
    function currentOptions() {
      return {

        showGrid,

        fontSize: FIXED_FONT_SIZE,
        padding: FIXED_PADDING,
        gridAdjust: { ...gridAdjust }
      };
    }

    function applyOptions(opts) {

      showGrid = opts.showGrid !== false;
      if (showGridToggle) showGridToggle.checked = showGrid;
      const adj = opts.gridAdjust || {};
      gridAdjust.scale = Number.isFinite(adj.scale) ? clamp(adj.scale, 10, 400) : DEFAULT_GRID_ADJUST.scale;
      gridAdjust.offsetX = Number.isFinite(adj.offsetX) ? adj.offsetX : DEFAULT_GRID_ADJUST.offsetX;
      gridAdjust.offsetY = Number.isFinite(adj.offsetY) ? adj.offsetY : DEFAULT_GRID_ADJUST.offsetY;

      if (gridScaleInput) gridScaleInput.value = gridAdjust.scale;
      if (gridOffsetXInput) gridOffsetXInput.value = gridAdjust.offsetX;
      if (gridOffsetYInput) gridOffsetYInput.value = gridAdjust.offsetY;
      applyGridAdjustments();
      draw();
    }

    function applyGridAdjustments() {
      if (!gridBase) { gridInfo = null; return; }

      const scale = (gridAdjust.scale || DEFAULT_GRID_ADJUST.scale) / 100;

      const radius = gridBase.radius * scale;
      const hexHeight = Math.sqrt(3) * radius;
      const firstX = gridBase.firstX + gridAdjust.offsetX;
      const firstY = gridBase.firstY + gridAdjust.offsetY;
      const cells = [];
      for (let col = 0; col < gridBase.cols; col++) {
        const baseX = firstX + col * (1.5 * radius);
        const offsetY = (col % 2 === 0) ? 0 : hexHeight / 2;
        for (let row = 0; row < gridBase.rows; row++) {
          const cy = firstY + row * hexHeight + offsetY;
          const id = `${String(col + 1).padStart(2, '0')}${String(row + 1).padStart(2, '0')}`;
          cells.push({ id, col, row, x: baseX, y: cy });
        }
      }
      gridInfo = { ...gridBase, radius, hexHeight, cells };
    }

    // Draw grid visualization
    function drawGrid() {
      if (!showGrid || !gridInfo) return '';
      const pieces = [];
      const { cells, radius } = gridInfo;
      for (const cell of cells) {
        pieces.push(`<path class="grid-cell" d="${hexPath(cell.x, cell.y, radius)}" />`);
      }
      for (const cell of cells) {
        pieces.push(`<text class="grid-label" x="${cell.x}" y="${cell.y+4}">${cell.id}</text>`);
      }
      return pieces.join('');
    }

    // --- Coordinate helpers (image space)
    function clientToImageXY(evt) {
      const rect = mapImg.getBoundingClientRect();
      const scaleX = mapImg.naturalWidth / rect.width;
      const scaleY = mapImg.naturalHeight / rect.height;
      const x = (evt.clientX - rect.left) * scaleX;
      const y = (evt.clientY - rect.top) * scaleY;
      return [x, y];
    }

    function sizeOverlay() {
      overlay.setAttribute('viewBox', `0 0 ${mapImg.naturalWidth} ${mapImg.naturalHeight}`);
      overlay.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      canvasWrap.style.width = `${mapImg.naturalWidth}px`;
      canvasWrap.style.height = `${mapImg.naturalHeight}px`;
    }

    // --- Label rendering
    function draw() {
      const fs = FIXED_FONT_SIZE; const padding = FIXED_PADDING;
      const items = labels.map(l => l?.kind === 'icon' ? iconNode(l) : labelNode(l, fs, padding)).join('');
      const gridSvg = drawGrid();
      overlay.innerHTML = `<g id="grid">${gridSvg}</g><g id="labels">${items}</g>`;
      // reattach events for labels
      overlay.querySelectorAll('.map-item').forEach(g => {
        g.addEventListener('click', (e) => { e.stopPropagation(); openEditor(g.dataset.id); });
      });
      overlay.style.pointerEvents = 'auto';
      renderLabelList();
    }

    function labelNode(l, fs, padding) {
      const tid = (l.hex || '').trim();
      const textLines = (l.text || '').split('\n');
      const lineHeight = fs + 2;
      const width = Math.max(40, ...textLines.map(s => s.length * (fs * 0.6))) + padding*2;
      const height = lineHeight * textLines.length + (tid ? 12 : 0) + padding*2;
      const x = l.x - width/2; const y = l.y - height/2;
      const lines = textLines.map((s,i)=>`<text x="${l.x}" y="${y + padding + lineHeight/2 + i*lineHeight}" font-size="${fs}">${escapeHtml(s)}</text>`).join('');
      const hexLine = tid ? `<text class="hexid" x="${l.x}" y="${y + height - padding - 6}" font-size="10">${escapeHtml(tid)}</text>` : '';
      return `<g class="map-item label" data-id="${l.id}">
        <rect x="${x}" y="${y}" width="${width}" height="${height}" />
        ${lines}
        ${hexLine}
      </g>`;
    }

    function escapeHtml(s){
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }

    function renderLabelList() {
      if (!labelList) return;
      const filterText = labelFilter ? labelFilter.value.trim().toLowerCase() : '';
      const entries = [];
      for (const l of labels) {
        if (!l) continue;
        const hex = (l.hex || '').trim();
        const iconName = l.kind === 'icon' ? (ICON_LOOKUP[l.iconId]?.label || l.iconId || 'Icon') : '';
        const firstLine = (l.text || '').split('\n').map(part => part.trim()).find(Boolean) || '';
        const title = l.kind === 'icon'
          ? (firstLine || iconName)
          : (firstLine || 'Untitled label');
        const haystack = `${hex} ${iconName} ${l.text || ''}`.toLowerCase();
        if (filterText && !haystack.includes(filterText)) {
          continue;
        }
        const hexDisplay = hex ? escapeHtml(hex) : 'â€”';
        const titleDisplay = title ? escapeHtml(title) : 'Untitled label';
        const kindLabel = l.kind === 'icon' ? 'Icon' : 'Text';
        entries.push(`
          <button type="button" class="label-list-item${selectedId === l.id ? ' is-active' : ''}" data-id="${l.id}">
            <span class="label-list-hex">${hexDisplay}</span>
            <span class="label-list-title">${titleDisplay}</span>
            <span class="label-list-kind">${kindLabel}</span>
          </button>
        `);
      }
      if (!entries.length) {
        labelList.innerHTML = `<div class="label-list-empty">${labels.length ? 'No matching labels.' : 'No labels yet.'}</div>`;
        return;
      }
      labelList.innerHTML = entries.join('');
    }

    function focusLabelOnMap(label) {
      if (!label) return;
      fitToWindow(true);
      requestAnimationFrame(() => {
        const scale = viewState.scale || 1;
        const vw = viewport.clientWidth;
        const vh = viewport.clientHeight;
        if (!vw || !vh) return;
        viewState.x = vw / 2 - label.x * scale;
        viewState.y = vh / 2 - label.y * scale;
        applyView();
      });
    }

    // --- Interactions
    overlay.addEventListener('click', (e) => {
      if (isPanning) return;
      const [ix, iy] = clientToImageXY(e);
      const dupFrom = e.shiftKey ? labels.find(l => l.id === selectedId) : null;
      createLabelAt(ix, iy, { duplicateFrom: dupFrom });
    });

    function createLabelAt(ix, iy, { duplicateFrom = null, kind = null, iconId = null } = {}) {
      const snap = snapToGrid(ix, iy);
      const x = snap ? snap.x : ix;
      const y = snap ? snap.y : iy;
      const base = duplicateFrom ? duplicateFrom : null;
      const resolvedKind = kind || (base ? base.kind : 'text');
      let resolvedIcon = iconId || (base && base.kind === 'icon' ? base.iconId : ICONS[0].id);
      if (!ICON_LOOKUP[resolvedIcon]) {
        resolvedIcon = ICONS[0].id;
      }
      const newLabel = {
        id: crypto.randomUUID(),
        kind: resolvedKind,
        iconId: resolvedIcon,
        x,
        y,
        hex: snap ? snap.id : '',
        text: base ? base.text : ''
      };
      labels.push(newLabel);
      selectedId = newLabel.id;
      openEditor(newLabel.id, true);
      draw();
      saveState();
    }

    function openEditor(id, isNew = false) {
      selectedId = id;
      const l = labels.find(x => x.id === id); if (!l) return;
      f_hex.value = l.hex || '';
      f_xy.value = `${l.x.toFixed(1)}, ${l.y.toFixed(1)}`;
      const kind = l.kind === 'icon' ? 'icon' : 'text';
      if (f_icon) {
        const iconVal = ICON_LOOKUP[l.iconId] ? l.iconId : ICONS[0].id;
        f_icon.value = iconVal;
      }
      if (f_text) {
        f_text.value = l.text || '';
      }
      updateEditorMode(kind);
      delBtn.onclick = () => { if (confirm('Delete this label?')) { labels = labels.filter(x => x.id !== id); dlg.close(); draw(); saveState(); } };
      dlg.dataset.isNew = isNew ? '1' : '';
      dlg.showModal();
    }

    dlg.addEventListener('close', () => {
      const isNew = dlg.dataset.isNew === '1';
      if (dlg.returnValue !== 'ok') {
        if (isNew) {
          labels = labels.filter(x => x.id !== selectedId);
          selectedId = null;
          draw(); saveState();
        }
        return;
      }
      const l = labels.find(x => x.id === selectedId); if (!l) return;
      l.hex = f_hex.value.trim();
      const kind = dlg.dataset.kind === 'icon' ? 'icon' : 'text';
      l.kind = kind;
      if (kind === 'icon') {
        let iconVal = f_icon ? f_icon.value : ICONS[0].id;
        if (!ICON_LOOKUP[iconVal]) iconVal = ICONS[0].id;
        l.iconId = iconVal;
      }
      l.text = f_text ? f_text.value : '';
      draw(); saveState();
    });

    // Drag labels
    let draggingId = null;
    overlay.addEventListener('mousedown', (e) => {
      const target = e.target.closest('.map-item');
      if (!target) return;
      draggingId = target.dataset.id; selectedId = draggingId;
      const [startX, startY] = clientToImageXY(e);
      const l = labels.find(x => x.id === draggingId);
      const ox = l.x - startX, oy = l.y - startY;
      function move(ev){
        const [mx, my] = clientToImageXY(ev);
        let nx = mx + ox, ny = my + oy;
        const snap = snapToGrid(nx, ny);
        if (snap) { l.x = snap.x; l.y = snap.y; l.hex = snap.id; }
        else { l.x = nx; l.y = ny; }
        draw();
      }
      function up(){ window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up); saveState(); }
      window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
    });

    // Keyboard delete
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Delete' && selectedId) { labels = labels.filter(l => l.id !== selectedId); selectedId = null; draw(); saveState(); }
    });

    // Persist UI -> redraw
    mapId.addEventListener('change', async () => {
      const found = await loadState({ preferRemote: true });
      if (!found) {
        labels = [];
        draw();
        saveState();
      }
    });

    // Initial image: try to preload the provided path if available
    (async function init(){
      draw();
      // Attempt to load the bundled Dolmenwood map by default. Fallback to any saved state if loading fails.
      try {
        await setImage('Dolmenwood_Blank_Hex_Map.png');
      } catch(err) {
        console.warn('Failed to load bundled map image:', err);
      }
      // Attempt to load any saved state for default project
      const loaded = await loadState({ preferRemote: true });
      if (!loaded) {
        saveState();
      }
    })();

    // --- Grid analysis
    const gridPresets = {
      'dolmenwood_blank_hex_map.png': { cols: 19, rows: 12 }
    };

    async function analyzeImage() {
      const w = mapImg.naturalWidth, h = mapImg.naturalHeight;
      if (!w || !h) { gridBase = null; gridInfo = null; return; }
      const canvas = document.createElement('canvas');
      const maxDim = 1000;
      const scale = Math.min(1, maxDim / Math.max(w, h));
      const sw = Math.max(1, Math.round(w * scale));
      const sh = Math.max(1, Math.round(h * scale));
      canvas.width = sw; canvas.height = sh;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(mapImg, 0, 0, sw, sh);
      let data;
      try {
        data = ctx.getImageData(0, 0, sw, sh).data;
      } catch(err) {
        console.warn('Unable to analyze grid from image', err);
        gridBase = null;
        gridInfo = null;
        return;
      }
      let minX = sw, minY = sh, maxX = 0, maxY = 0;
      for (let y = 0; y < sh; y++) {
        for (let x = 0; x < sw; x++) {
          const idx = (y * sw + x) * 4;
          const r = data[idx], g = data[idx+1], b = data[idx+2];
          if (r < 245 || g < 245 || b < 245) {
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }
        }
      }
      if (minX > maxX || minY > maxY) {
        gridBase = null;
        gridInfo = null;
        return;
      }
      const bounds = {
        left: minX / scale,
        top: minY / scale,
        right: (maxX + 1) / scale,
        bottom: (maxY + 1) / scale
      };
      const fileName = (mapImg.src.split('/').pop() || '').toLowerCase();
      const preset = gridPresets[fileName] || { cols: 19, rows: 12 };
      const width = bounds.right - bounds.left;
      const height = bounds.bottom - bounds.top;
      const rW = width / (1.5 * (preset.cols - 1) + 2);
      const rH = (height / preset.rows) / Math.sqrt(3);
      const radius = (rW + rH) / 2;
      const hexHeight = Math.sqrt(3) * radius;
      const firstX = bounds.left + radius;
      const firstY = bounds.top + hexHeight / 2;
      gridBase = {
        bounds,
        radius,
        hexHeight,
        cols: preset.cols,
        rows: preset.rows,
        firstX,
        firstY
      };
      applyGridAdjustments();
    }

    function hexPath(cx, cy, r) {
      const pts = [];
      for (let i = 0; i < 6; i++) {

        const angle = (Math.PI / 180) * (60 * i);

        const px = cx + r * Math.cos(angle);
        const py = cy + r * Math.sin(angle);
        pts.push(`${px},${py}`);
      }
      return `M${pts.join(' L')} Z`;
    }

    function snapToGrid(x, y) {
      if (!gridInfo) return null;
      let best = null; let bestDist = Infinity;
      for (const cell of gridInfo.cells) {
        const dx = cell.x - x;
        const dy = cell.y - y;
        const dist = dx*dx + dy*dy;
        if (dist < bestDist) { bestDist = dist; best = cell; }
      }
      if (!best) return null;
      return { ...best };
    }

    // --- Zoom & pan
    let isPanning = false;
    let panPointer = null;
    let panStart = null;

    viewport.addEventListener('pointerdown', (evt) => {
      if (evt.button !== 0) return;
      const target = evt.target;
      if (target.closest('svg') && target.closest('.map-item')) return; // let marker dragging handle it
      isPanning = true;
      panPointer = evt.pointerId;
      panStart = { x: evt.clientX - viewState.x, y: evt.clientY - viewState.y };
      viewport.classList.add('is-panning');
      if (viewport.setPointerCapture) viewport.setPointerCapture(evt.pointerId);
    });

    viewport.addEventListener('pointermove', (evt) => {
      if (!isPanning || evt.pointerId !== panPointer) return;
      viewState.x = evt.clientX - panStart.x;
      viewState.y = evt.clientY - panStart.y;
      applyView();
    });

    viewport.addEventListener('pointerup', endPan);
    viewport.addEventListener('pointercancel', endPan);

    function endPan(evt) {
      if (!isPanning || evt.pointerId !== panPointer) return;
      isPanning = false;
      panPointer = null;
      viewport.classList.remove('is-panning');
      if (viewport.hasPointerCapture && viewport.hasPointerCapture(evt.pointerId)) {
        viewport.releasePointerCapture(evt.pointerId);
      }
    }

    viewport.addEventListener('wheel', (evt) => {
      evt.preventDefault();
      const scaleFactor = Math.exp(-evt.deltaY * 0.0015);
      const newScale = clamp(viewState.scale * scaleFactor, 0.25, 4);
      const rect = viewport.getBoundingClientRect();
      const offsetX = evt.clientX - rect.left;
      const offsetY = evt.clientY - rect.top;
      const dx = offsetX - viewState.x;
      const dy = offsetY - viewState.y;
      const ratio = newScale / viewState.scale;
      viewState.x = offsetX - dx * ratio;
      viewState.y = offsetY - dy * ratio;
      viewState.scale = newScale;
      applyView();
    }, { passive: false });

    function applyView() {
      canvasWrap.style.transform = `translate(${viewState.x}px, ${viewState.y}px) scale(${viewState.scale})`;
    }

    function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

    function resetGridAdjustments() {

      gridAdjust = { ...DEFAULT_GRID_ADJUST };

      if (gridScaleInput) gridScaleInput.value = gridAdjust.scale;
      if (gridOffsetXInput) gridOffsetXInput.value = gridAdjust.offsetX;
      if (gridOffsetYInput) gridOffsetYInput.value = gridAdjust.offsetY;
      applyGridAdjustments();
      draw();
      saveState();
    }


    if (showGridToggle) {
      showGridToggle.addEventListener('change', () => {
        showGrid = showGridToggle.checked;
        draw();
        saveState();
      });
    }

    if (gridScaleInput && gridOffsetXInput && gridOffsetYInput && resetGridBtn) {
      gridScaleInput.addEventListener('change', () => {
        const value = parseFloat(gridScaleInput.value);
        gridAdjust.scale = Number.isFinite(value) ? clamp(value, 10, 400) : DEFAULT_GRID_ADJUST.scale;

        gridScaleInput.value = gridAdjust.scale;
        applyGridAdjustments();
        draw();
        saveState();
      });
      const handleOffsetChange = () => {
        const offX = parseFloat(gridOffsetXInput.value);
        const offY = parseFloat(gridOffsetYInput.value);

        gridAdjust.offsetX = Number.isFinite(offX) ? offX : DEFAULT_GRID_ADJUST.offsetX;
        gridAdjust.offsetY = Number.isFinite(offY) ? offY : DEFAULT_GRID_ADJUST.offsetY;

        applyGridAdjustments();
        draw();
        saveState();
      };
      gridOffsetXInput.addEventListener('change', handleOffsetChange);
      gridOffsetYInput.addEventListener('change', handleOffsetChange);
      resetGridBtn.addEventListener('click', resetGridAdjustments);
    }

    function fitToWindow(animated = false) {
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;
      if (!mapImg.naturalWidth || !mapImg.naturalHeight) return;
      const scale = Math.min(vw / mapImg.naturalWidth, vh / mapImg.naturalHeight) || 1;
      const newX = (vw - mapImg.naturalWidth * scale) / 2;
      const newY = (vh - mapImg.naturalHeight * scale) / 2;
      viewState.scale = scale;
      viewState.x = newX;
      viewState.y = newY;
      if (animated) {
        canvasWrap.style.transition = 'transform 0.2s ease';
        requestAnimationFrame(() => {
          applyView();
          setTimeout(() => { canvasWrap.style.transition = ''; }, 200);
        });
      } else {
        applyView();
      }
    }

    // Drag-and-drop label creation
    const newLabelChip = document.getElementById('newLabelChip');
    newLabelChip.addEventListener('dragstart', (evt) => {
      evt.dataTransfer.effectAllowed = 'copy';
      evt.dataTransfer.setData('application/x-hexlabel', 'text:new');
      viewport.classList.add('droppable');
    });

    newLabelChip.addEventListener('dragend', () => {
      viewport.classList.remove('droppable');
    });

    function allowLabelDrop(evt) {
      if (!evt.dataTransfer) return;
      const types = Array.from(evt.dataTransfer.types || []);
      if (types.includes('application/x-hexlabel')) {
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy';
        viewport.classList.add('droppable');
      }
    }

    viewport.addEventListener('dragover', allowLabelDrop);
    viewport.addEventListener('dragenter', allowLabelDrop);
    viewport.addEventListener('dragleave', (evt) => {
      if (evt.relatedTarget && viewport.contains(evt.relatedTarget)) return;
      viewport.classList.remove('droppable');
    });

    viewport.addEventListener('drop', (evt) => {
      if (!evt.dataTransfer) return;
      const marker = evt.dataTransfer.getData('application/x-hexlabel');
      viewport.classList.remove('droppable');
      if (!marker) return;
      evt.preventDefault();
      const rect = mapImg.getBoundingClientRect();
      if (evt.clientX < rect.left || evt.clientX > rect.right || evt.clientY < rect.top || evt.clientY > rect.bottom) {
        return;
      }
      const [ix, iy] = clientToImageXY(evt);
      if (marker === 'new' || marker === 'text:new') {
        createLabelAt(ix, iy);
      } else if (marker.startsWith('icon:')) {
        const iconId = marker.slice(5);
        createLabelAt(ix, iy, { kind: 'icon', iconId });
      }
    });
  </script>
</body>
</html>
